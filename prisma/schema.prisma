generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

enum UserRole {
  USER
  MODERATOR
  ADMIN
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  DECLINED
  BLOCKED
}

enum PostType {
  TEXT
  IMAGE
  VIDEO
  LINK
  SHARED
  STORY
}

enum PostAudience {
  PUBLIC
  FRIENDS
  ONLY_ME
  CUSTOM
}

enum ReactionType {
  LIKE
  LOVE
  HAHA
  WOW
  SAD
  ANGRY
}

enum TargetType {
  POST
  COMMENT
}

enum ConversationType {
  DIRECT
  GROUP
}

enum ConversationMemberRole {
  MEMBER
  ADMIN
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  FILE
  AUDIO
  SYSTEM
  EMOJI
  REPLY
}

enum NotificationType {
  FRIEND_REQUEST
  FRIEND_ACCEPTED
  POST_LIKE
  POST_COMMENT
  COMMENT_REPLY
  COMMENT_LIKE
  POST_SHARE
  POST_TAG
  GROUP_INVITE
  EVENT_INVITE
  BIRTHDAY
  SYSTEM
}

enum NotificationTargetType {
  POST
  COMMENT
  FRIENDSHIP
  GROUP
  EVENT
  USER
}

enum GroupPrivacy {
  PUBLIC
  PRIVATE
  SECRET
}

enum GroupMemberRole {
  MEMBER
  MODERATOR
  ADMIN
}

enum EventPrivacy {
  PUBLIC
  PRIVATE
}

enum EventAttendeeStatus {
  GOING
  INTERESTED
  NOT_GOING
}

enum StoryMediaType {
  IMAGE
  VIDEO
}

enum ReportTargetType {
  USER
  POST
  COMMENT
  MESSAGE
  GROUP
}

enum ReportReason {
  SPAM
  HARASSMENT
  HATE_SPEECH
  VIOLENCE
  NUDITY
  MISINFORMATION
  OTHER
}

enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
  DISMISSED
}

model User {
  id              String    @id @default(uuid())
  email           String    @unique @db.VarChar(255)
  emailVerified   DateTime?
  passwordHash    String?
  username        String    @unique @db.VarChar(30)
  displayName     String    @db.VarChar(50)
  bio             String?   @db.VarChar(500)
  avatarUrl       String?
  coverImageUrl   String?
  dateOfBirth     DateTime?
  gender          Gender?
  location        String?   @db.VarChar(100)
  website         String?   @db.VarChar(200)
  phone           String?
  isVerified      Boolean   @default(false)
  isPrivate       Boolean   @default(false)
  isOnline        Boolean   @default(false)
  lastSeenAt      DateTime  @default(now())
  role            UserRole  @default(USER)
  privacySettings Json      @default("{}")
  notificationSettings Json @default("{}")
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?

  // Relations
  sentFriendRequests     Friendship[] @relation("FriendshipRequester")
  receivedFriendRequests Friendship[] @relation("FriendshipAddressee")
  posts                  Post[]
  comments               Comment[]
  reactions              Reaction[]
  conversationMembers    ConversationMember[]
  sentMessages           Message[]
  notifications          Notification[] @relation("NotificationRecipient")
  actedNotifications     Notification[] @relation("NotificationActor")
  createdGroups          Group[]        @relation("GroupCreator")
  groupMembers           GroupMember[]
  hostedEvents           Event[]        @relation("EventHost")
  eventAttendees         EventAttendee[]
  stories                Story[]
  storyViews             StoryView[]
  reports                Report[]       @relation("Reporter")
  reviewedReports        Report[]       @relation("ReportReviewer")
  createdConversations   Conversation[] @relation("ConversationCreator")
  accounts               Account[]
  sessions               Session[]

  @@index([email])
  @@index([username])
  @@index([createdAt])
  @@index([isOnline])
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Friendship {
  id          String           @id @default(uuid())
  requesterId String
  addresseeId String
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  requester User @relation("FriendshipRequester", fields: [requesterId], references: [id], onDelete: Cascade)
  addressee User @relation("FriendshipAddressee", fields: [addresseeId], references: [id], onDelete: Cascade)

  @@unique([requesterId, addresseeId])
  @@index([addresseeId, status])
  @@index([requesterId, status])
}

model Post {
  id               String       @id @default(uuid())
  authorId         String
  content          String?      @db.Text
  contentPlainText String?      @db.Text
  type             PostType     @default(TEXT)
  audience         PostAudience @default(PUBLIC)
  customAudienceIds String[]
  mediaUrls        Json         @default("[]")
  linkPreview      Json?
  sharedPostId     String?
  feeling          String?      @db.VarChar(50)
  location         String?      @db.VarChar(200)
  taggedUserIds    String[]
  likeCount        Int          @default(0)
  commentCount     Int          @default(0)
  shareCount       Int          @default(0)
  isEdited         Boolean      @default(false)
  isPinned         Boolean      @default(false)
  expiresAt        DateTime?
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  deletedAt        DateTime?

  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  sharedPost  Post?     @relation("SharedPost", fields: [sharedPostId], references: [id])
  shares      Post[]    @relation("SharedPost")
  comments    Comment[]

  // Group post relation
  groupId String?
  group   Group?  @relation(fields: [groupId], references: [id])

  @@index([authorId, createdAt(sort: Desc)])
  @@index([type, createdAt(sort: Desc)])
  @@index([audience, createdAt(sort: Desc)])
  @@index([expiresAt])
  @@index([groupId, createdAt(sort: Desc)])
}

model Comment {
  id              String    @id @default(uuid())
  postId          String
  authorId        String
  parentCommentId String?
  content         String    @db.VarChar(5000)
  mediaUrl        String?
  likeCount       Int       @default(0)
  replyCount      Int       @default(0)
  depth           Int       @default(0)
  isEdited        Boolean   @default(false)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?

  post          Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  author        User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parentComment Comment?  @relation("CommentReplies", fields: [parentCommentId], references: [id])
  replies       Comment[] @relation("CommentReplies")

  @@index([postId, createdAt])
  @@index([parentCommentId, createdAt])
  @@index([authorId, createdAt])
}

model Reaction {
  id         String       @id @default(uuid())
  userId     String
  targetId   String
  targetType TargetType
  type       ReactionType
  createdAt  DateTime     @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, targetId, targetType])
  @@index([targetId, targetType, type])
}

model Conversation {
  id            String           @id @default(uuid())
  type          ConversationType
  name          String?          @db.VarChar(100)
  avatarUrl     String?
  creatorId     String
  lastMessageId String?
  lastMessageAt DateTime         @default(now())
  memberCount   Int              @default(2)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  creator  User                 @relation("ConversationCreator", fields: [creatorId], references: [id])
  members  ConversationMember[]
  messages Message[]

  @@index([lastMessageAt(sort: Desc)])
}

model ConversationMember {
  id                String                 @id @default(uuid())
  conversationId    String
  userId            String
  role              ConversationMemberRole @default(MEMBER)
  nickname          String?                @db.VarChar(50)
  lastReadMessageId String?
  isMuted           Boolean                @default(false)
  joinedAt          DateTime               @default(now())
  leftAt            DateTime?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId, leftAt])
}

model Message {
  id               String      @id @default(uuid())
  conversationId   String
  senderId         String
  content          String?     @db.Text
  type             MessageType @default(TEXT)
  mediaUrl         String?
  replyToMessageId String?
  readBy           Json        @default("[]")
  isEdited         Boolean     @default(false)
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  deletedAt        DateTime?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
  replyTo      Message?     @relation("MessageReply", fields: [replyToMessageId], references: [id])
  replies      Message[]    @relation("MessageReply")

  @@index([conversationId, createdAt(sort: Desc)])
  @@index([senderId, createdAt])
}

model Notification {
  id          String                 @id @default(uuid())
  recipientId String
  actorId     String
  type        NotificationType
  targetId    String?
  targetType  NotificationTargetType?
  message     String                 @db.VarChar(500)
  isRead      Boolean                @default(false)
  createdAt   DateTime               @default(now())

  recipient User @relation("NotificationRecipient", fields: [recipientId], references: [id], onDelete: Cascade)
  actor     User @relation("NotificationActor", fields: [actorId], references: [id], onDelete: Cascade)

  @@index([recipientId, isRead, createdAt(sort: Desc)])
  @@index([recipientId, createdAt(sort: Desc)])
}

model Group {
  id            String       @id @default(uuid())
  name          String       @db.VarChar(100)
  description   String?      @db.VarChar(2000)
  coverImageUrl String?
  avatarUrl     String?
  privacy       GroupPrivacy  @default(PUBLIC)
  creatorId     String
  memberCount   Int          @default(1)
  postCount     Int          @default(0)
  rules         String?      @db.VarChar(5000)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  creator User          @relation("GroupCreator", fields: [creatorId], references: [id])
  members GroupMember[]
  posts   Post[]
  events  Event[]

  @@index([name])
  @@index([privacy, memberCount(sort: Desc)])
  @@index([creatorId])
}

model GroupMember {
  id       String          @id @default(uuid())
  groupId  String
  userId   String
  role     GroupMemberRole  @default(MEMBER)
  joinedAt DateTime        @default(now())
  leftAt   DateTime?

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([userId, leftAt])
}

model Event {
  id              String       @id @default(uuid())
  name            String       @db.VarChar(200)
  description     String?      @db.VarChar(5000)
  coverImageUrl   String?
  startDate       DateTime
  endDate         DateTime?
  location        String?      @db.VarChar(300)
  isOnline        Boolean      @default(false)
  onlineUrl       String?
  privacy         EventPrivacy @default(PUBLIC)
  hostId          String
  groupId         String?
  attendeeCount   Int          @default(0)
  interestedCount Int          @default(0)
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  host      User            @relation("EventHost", fields: [hostId], references: [id])
  group     Group?          @relation(fields: [groupId], references: [id])
  attendees EventAttendee[]

  @@index([startDate])
  @@index([hostId, startDate])
  @@index([groupId, startDate])
}

model EventAttendee {
  id        String              @id @default(uuid())
  eventId   String
  userId    String
  status    EventAttendeeStatus
  createdAt DateTime            @default(now())

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([userId, status])
}

model Story {
  id              String         @id @default(uuid())
  authorId        String
  mediaUrl        String
  mediaType       StoryMediaType
  caption         String?        @db.VarChar(500)
  backgroundColor String?
  viewCount       Int            @default(0)
  expiresAt       DateTime
  createdAt       DateTime       @default(now())

  author User        @relation(fields: [authorId], references: [id], onDelete: Cascade)
  views  StoryView[]

  @@index([authorId, createdAt])
  @@index([expiresAt])
}

model StoryView {
  id       String   @id @default(uuid())
  storyId  String
  viewerId String
  viewedAt DateTime @default(now())

  story  Story @relation(fields: [storyId], references: [id], onDelete: Cascade)
  viewer User  @relation(fields: [viewerId], references: [id], onDelete: Cascade)

  @@unique([storyId, viewerId])
  @@index([storyId, viewedAt])
}

model Report {
  id          String           @id @default(uuid())
  reporterId  String
  targetId    String
  targetType  ReportTargetType
  reason      ReportReason
  description String?          @db.VarChar(1000)
  status      ReportStatus     @default(PENDING)
  reviewedBy  String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  reporter User  @relation("Reporter", fields: [reporterId], references: [id])
  reviewer User? @relation("ReportReviewer", fields: [reviewedBy], references: [id])

  @@index([status, createdAt])
  @@index([targetId, targetType])
  @@index([reporterId, createdAt])
}
